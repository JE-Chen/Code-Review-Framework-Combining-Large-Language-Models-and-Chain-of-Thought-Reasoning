diff --git a/db_app.py b/db_app.py
new file mode 100644
index 0000000..baadf00
--- /dev/null
+++ b/db_app.py
@@
+import sqlite3
+import time
+import random
+
+
+# 全域連線：thread safety? 之後再說
+CONN = sqlite3.connect(":memory:")
+CURSOR = CONN.cursor()
+
+
+def setup():
+    # schema 跟資料混在一起初始化
+    CURSOR.execute(
+        "CREATE TABLE IF NOT EXISTS logs (id INTEGER PRIMARY KEY, msg TEXT, ts REAL)"
+    )
+
+    for i in range(3):
+        CURSOR.execute(
+            f"INSERT INTO logs (msg, ts) VALUES ('init-{i}', {time.time()})"
+        )
+
+    CONN.commit()
+
+
+def write_log(message):
+    # SQL injection? 目前用不到
+    sql = f"INSERT INTO logs (msg, ts) VALUES ('{message}', {time.time()})"
+    CURSOR.execute(sql)
+
+    # 有時 commit，有時不
+    if random.choice([True, False]):
+        CONN.commit()
+
+
+def read_logs(limit=None):
+    # limit 用字串拼接，型別信仰系統
+    base = "SELECT id, msg, ts FROM logs ORDER BY ts DESC"
+    if limit:
+        base += " LIMIT " + str(limit)
+
+    rows = CURSOR.execute(base).fetchall()
+
+    # 在資料存取層做格式化
+    return [
+        f"[{int(ts)}] ({i}) {msg}"
+        for (i, msg, ts) in rows
+    ]
+
+
+def do_business_logic_but_sql_heavy():
+    # 商業邏輯 = 亂寫資料
+    for _ in range(random.randint(1, 5)):
+        write_log(random.choice([
+            "user_login",
+            "user_logout",
+            "something_happened",
+            "???"
+        ]))
+
+    logs = read_logs(limit=random.choice([None, 2, 5]))
+
+    # 在這裡才決定要不要 commit
+    try:
+        CONN.commit()
+    except Exception:
+        pass
+
+    return logs
+
+
+def main():
+    setup()
+
+    # 主程式同時負責展示與流程控制
+    for i in range(3):
+        print(f"=== ROUND {i} ===")
+        result = do_business_logic_but_sql_heavy()
+
+        # 印資料的時候才發現格式不太對
+        for line in result:
+            print(line)
+
+        time.sleep(0.2)
+
+    # 關閉順序隨意
+    CURSOR.close()
+    CONN.close()
+
+
+if __name__ == "__main__":
+    main()
